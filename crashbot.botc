#!botc 2.0.0

//*************************************************************************************************************
// This is the bot AI script for a generic bot. A quick explanation on how a script works.
//
// The bot's logic is organized into a series of states. Initially, the bot starts in the stateSpawn state
// (every script must include this!), and from there the bot can be scripted to do whatever the scripter wants.
// Each state has three subsections: onenter, mainloop, and onexit. Every time a new state is entered into, the
// code in its onenter section is executed. After that, the code in its mainloop will be executed until a
// changestate command is called. At that point, the code in its onexit section is executed. After that, the
// state changes to the desired state, and the whole thing starts over again.
//
// The bot can also respond to events that take place in the world. It is up to the script to decide which
// events to respond to in any given state. <more here>

#include "botc_defs.bts"

int g_iChatTimer;
int g_iAllowSearch[];
int g_iMorale;
int g_iMoraleTimer;
int g_iEnragedTimer;
int g_iDemoralizedTimer;

//*************************************************************************************************************
// In this section we list all the states that will be used in the script,
// this is required to refer them by name in changestate calls
state	stateSpawn;
state	stateStandardRoam;
state	stateSortThroughWeapons;
state	stateSortThroughPowerups;
state	stateSortThroughBaseHealth;
state	stateSortThroughBaseArmor;
state	stateSortThroughSuperHealth;
state	stateSortThroughSuperArmor;
//state	stateSortThroughAmmo;
state	statePathToGoal;
state	stateEngageEnemy;
state	stateChaseEnemy;
state	stateKilled;
state	stateRespawn;
state	stateKilledEnemy;
state	stateIntermission;
state	stateSpectating;
state	stateDuelWinSequence;

//*************************************************************************************************************
//	This is the speed the bot moves at, as a % of maximum speed.
const int MOVEMENT_SPEED = 100;

//*************************************************************************************************************
// This is where the global events that are responded to are listed. If this event happens at any time, this is
// the response that will occur, regardless of the state.
	event Intermission {
        // If we're not a spectator, change to the intermission state.
		if (!IsSpectating()) {
			changestate(stateIntermission);
		}
	}

    // We've seen set as a spectator, so go to the spectating state.
	event Spectating {
		changestate(stateSpectating);
	}

    // The duel countdown is starting!
	event DuelStartingCountdown {
        // If we're not a spectator, change to our freshly spawned state.
		if (!IsSpectating()) {
			changestate(stateSpawn);
		}
	}

    // The countdown has ended! It's time to fight!
	event DuelFight {
        // If we're actively part of this duel, start looking around for weapons, etc.
		if (!IsSpectating()) {
			if (LookForWeapons(0, true) != -1) {
				changestate(stateSortThroughWeapons);
			} else {
				changestate(stateStandardRoam);
			}
		}
	}

    // The duel has ended.
    event DuelWinSequence {
		if (!IsSpectating()) {
			changestate(stateDuelWinSequence);
		}
	}

    // The last man standing countdown is starting!
	event LMSStartingCountdown {
		if (!IsSpectating()) {
			changestate(stateSpawn);
		}
	}

    // The countdown has ended! It's time to fight!
    event LMSFight {
		if (!IsSpectating()) {
			if (LookForWeapons(0, true) != -1) {
				changestate(stateSortThroughWeapons);
			} else {
				changestate(stateStandardRoam);
			}
		}
	}

    // The LMS session has ended.
	event LMSWinSequence {
		if (!IsSpectating()) {
            // If we're still alive, we must have won!
			if (!IsDead()) {
				if (ChatSectionExistsInChatLump("WinStrings")) {
					BeginChatting();
					delay(Random(15, 45));

					SayFromChatLump("WinStrings");
				}
			} else {
				if (ChatSectionExistsInChatLump("LoseStrings")) {
					BeginChatting();
					delay(Random(15, 45));

					SayFromChatLump("LoseStrings");
				}
			}
		}
	}

    // Somebody said something.
	event PlayerSay {
        // Orion? WHAT DID HE SAY?!?!? :)))))))))))))
		if (StringsAreEqual("Orion", GetLastChatPlayer())) {
            // Aww :((((((((((((((((
			if (StringsAreEqual("Fuck you Crash", GetLastChatString())) {
				BeginChatting();
				delay(Random(15, 35));

				Say(":(");
				g_iChatTimer = 35 * 5;
			}
		
			if (StringsAreEqual("If you see Crash, tell her I have a girlfriend or something.", GetLastChatString())) {
				BeginChatting();
				delay(Random(15, 35));

				Say("What? Hey...");
				g_iChatTimer = 35 * 5;
			}
		}
	}

//*************************************************************************************************************
// This is the state a bot is placed in when he spawns. This state MUST be in the script!
state stateSpawn {

	event KilledByEnemy {
		changestate(stateKilled);
	}

	event KilledByPlayer {
		changestate(stateKilled);
	}

	event KilledBySelf {
		changestate(stateKilled);
	}

	event KilledByEnvironment {
		changestate(stateKilled);
	}

	onenter {
        // Start off with a morale of 100%.
		g_iMorale = 100;

        // Increase our morale every few seconds.
		g_iMoraleTimer = 35 * 3;
		g_iEnragedTimer = 0;
		g_iDemoralizedTimer = 0;

		delay(Random(0, 17));

        // If the bot has the "IntroStrings" section in their chatfile, say an opening line from there.
		if (ChatSectionExistsInChatLump("IntroStrings")) {
			BeginChatting();
			delay(Random(15, 35));

            // Say a little opening chat string.
			SayFromChatLump("IntroStrings");
		}

        // Don't say anything else for at least 5 seconds.
		g_iChatTimer = 35 * 5;

        // Weapons are the most important. Look for one. If we find one, decide which one is the
        // most important, then path to it. Otherwise, just start roaming around.
//		if (LookForWeapons(0, false) != -1) {
		if (LookForWeapons(0, true) != -1) {
			changestate(stateSortThroughWeapons);
		} else {
			changestate(stateStandardRoam);
		}
	}

	mainloop {
	}

	onexit {
        // If were were chatting in this state, get rid of the chat bubble above our head.
		StopChatting();
	}
}

//*************************************************************************************************************
state stateStandardRoam {
	int iWeapon;
	int iPowerup;
	int iBaseHealth;
	int iBaseArmor;
	int iSuperHealth;
	int iSuperArmor;
	int iReSearchTimer;
	int iSearchType;
	int iEnemy;
	int iChatFrequency;

	event KilledByEnemy {
		changestate(stateKilled);
	}

	event KilledByPlayer {
		changestate(stateKilled);
	}

	event KilledBySelf {
		changestate(stateKilled);
	}

	event KilledByEnvironment {
		changestate(stateKilled);
	}

	event DamagedByPlayer {
		if (!StringsAreEqual(GetCurrentWeapon(), "Pistol")) {
            // Make our enemy the last player that shot us.
			SetEnemy(GetPlayerDamagedBy());
			changestate(stateEngageEnemy);
		}
	}

	onenter {
		iWeapon = 0;
		iPowerup = 0;
		iBaseHealth = 0;
		iBaseArmor = 0;
		iSuperHealth = 0;
		iSuperArmor = 0;
		iSearchType = 0;
		memset(g_iAllowSearch, 1, 32768);

		iReSearchTimer = 2 * 35;
	}

    // Since we're in our spawn state, look around for things that may be of our interest.
	mainloop {
		switch (iSearchType) {
            case 0:

                // First, look for weapons. This function returns the next item in the item list that is
                // a weapon, starting with iWeapon.
                if (LookForWeapons(iWeapon, true) != -1) {
                    // If we were already unsuccessful trying to reach this item, don't try again.
                    if (g_iAllowSearch[iWeapon] != 0) {
                        iWeapon = LookForWeapons(iWeapon, true);

                        // If we don't currently posess the weapon, and can actually get to it, then we have
                        // at least ONE weapon that's worth trying to get. Change to the state
                        // stateSortThroughWeapons, which will search for all weapons, and decide which one
                        // is the best to pursue.
                        if (!IsWeaponOwned(iWeapon) && (GetPathingCostToItem(iWeapon) >= 0)) {
                            changestate(stateSortThroughWeapons);
                        } else {
                            // Since we couldn't get to this item, don't attempt to get it again.
                            g_iAllowSearch[iWeapon] = 0;
                        }
                    }

                    iWeapon++;
                } else {
                    // Next time we search for items of this type, start at the beginning of the list.
                    iWeapon = 0;

                    // Now that we're done searching for items of this type, move onto the next time.
                    iSearchType++;
                }
                break;
            case 1:
			// Next, search for powerups. This function returns the next item in the item list that is
			// a powerup, starting with iPowerup.
			if (LookForPowerups(iPowerup, true) != -1) {
				// If we were already unsuccessful trying to reach this item, don't try again.
				if (g_iAllowSearch[iPowerup] != 0) {
                    iPowerup = LookForPowerups(iPowerup, true);

					// If we can actually get to it, then we have at least ONE powerup that's worth
					// trying to get. Change to the state stateSortThroughPowerups, which will
					// search for all powerups, and decide which one is the best to pursue.
					if (GetPathingCostToItem(iPowerup) >= 0) {
						changestate(stateSortThroughPowerups);
					} else {
						// Since we couldn't get to this item, don't attempt to get it again.
						g_iAllowSearch[iPowerup] = 0;
					}
				}

				iPowerup++;
			} else {
				// Next time we search for items of this type, start at the beginning of the list.
				iPowerup = 0;

				// Now that we're done searching for items of this type, move onto the next time.
				iSearchType++;
			}

			break;
			case 2:

			// Next, search for health. If our health is lower than our base health, look around
			// for medkits, etc.
			if (GetHealth() < GetBaseHealth()) {
				// This function returns the next item in the item list that is a base health item,
				// starting with iBaseHealth.
				if (LookForBaseHealth(iBaseHealth, true) != -1) {
					// If we were already unsuccessful trying to reach this item, don't try again.
					if (g_iAllowSearch[iBaseHealth] != 0) {
						iBaseHealth = LookForBaseHealth(iBaseHealth, true);

						// If we can actually get to it, then we have at least ONE base health item
						// that's worth trying to get. Change to the state
						// stateSortThroughBaseHealth, which will search for all medkits, etc. and
						// decide which one is the best to pursue.
						if (GetPathingCostToItem(iBaseHealth) >= 0) {
							changestate(stateSortThroughBaseHealth);
						} else {
							// Since we couldn't get to this item, don't attempt to get it again.
							g_iAllowSearch[iBaseHealth] = 0;
						}
					}

					iBaseHealth++;
				} else {
					// Next time we search for items of this type, start at the beginning of the list.
					iBaseHealth = 0;

					// Now that we're done searching for items of this type, move onto the next time.
					iSearchType++;
				}
			}
            // Now that we're done searching for items of this type, move onto the next time.
			else {
				iSearchType++;
			}
			break;
			case 3:

			// Next, search for armor. If our armor is lower than our base armor, look around
			// for green armor, etc.
			if (GetArmor() < GetBaseArmor()) {
				// This function returns the next item in the item list that is a base armor item,
				// starting with iBaseArmor.
				if (LookForBaseArmor(iBaseArmor, true) != -1) {
					// If we were already unsuccessful trying to reach this item, don't try again.
					if (g_iAllowSearch[iBaseArmor] != 0) {
						iBaseArmor = LookForBaseArmor(iBaseArmor, true);

						// If we can actually get to it, then we have at least ONE base armor item
						// that's worth trying to get. Change to the state
						// stateSortThroughBaseArmor, which will search for all green armor, etc. and
						// decide which one is the best to pursue.
						if (GetPathingCostToItem(iBaseArmor) >= 0) {
							changestate(stateSortThroughBaseArmor);
						} else {
							// Since we couldn't get to this item, don't attempt to get it again.
							g_iAllowSearch[iBaseArmor] = 0;
						}
					}

					iBaseArmor++;
				} else {
					// Next time we search for items of this type, start at the beginning of the list.
					iBaseArmor = 0;

					// Now that we're done searching for items of this type, move onto the next time.
					iSearchType++;
				}
			} else {
				// Now that we're done searching for items of this type, move onto the next time.
				iSearchType++;
			}
			break;
			case 4:
			// Next, search for super health items. This function returns the next item in the item
			// list that is a super health item, starting with iSuperHealth.
			if (LookForSuperHealth(iSuperHealth, true) != -1) {
				// If we were already unsuccessful trying to reach this item, don't try again.
				if (g_iAllowSearch[iSuperHealth] != 0) {
                    iSuperHealth = LookForSuperHealth(iSuperHealth, true);

					// If we can actually get to it, then we have at least ONE super health item
					// that's worth trying to get. Change to the state stateSortThroughSperHealth,
					// which will search for all super health items, and decide which one is the
					// best to pursue.
					if (GetPathingCostToItem(iSuperHealth) >= 0) {
						changestate(stateSortThroughSuperHealth);
					} else {
						// Since we couldn't get to this item, don't attempt to get it again.
						g_iAllowSearch[iSuperHealth] = 0;
					}
				}
				iSuperHealth++;
			} else {
				// Next time we search for items of this type, start at the beginning of the list.
				iSuperHealth = 0;

				// Now that we're done searching for items of this type, move onto the next time.
				iSearchType++;
			}
			break;
			case 5:
            // Next, search for super armor items. This function returns the next item in the item
            // list that is a super armor item, starting with iSuperArmor.
			if (LookForSuperArmor(iSuperArmor, true) != -1) {
				// If we were already unsuccessful trying to reach this item, don't try again.
				if (g_iAllowSearch[iSuperArmor] != 0) {
					iSuperArmor = LookForSuperArmor(iSuperArmor, true);

					// If we can actually get to it, then we have at least ONE super armor item
					// that's worth trying to get. Change to the state stateSortThroughSuperArmor,
					// which will search for all super armor items, and decide which one is the
					// best to pursue.
					if (GetPathingCostToItem(iSuperArmor) >= 0) {
						changestate(stateSortThroughSuperArmor);
					} else {
						// Since we couldn't get to this item, don't attempt to get it again.
						g_iAllowSearch[iSuperArmor] = 0;
					}
				}

				iSuperArmor++;
			} else {
				// Next time we search for items of this type, start at the beginning of the list.
				iSuperArmor = 0;

				// Now that we're done searching for items of this type, move onto the next time.
				iSearchType++;
			}

			break;
        case 6:

			iSearchType = 0;
			break;
	}

		// Also, keep an eye out for opponents.
		if (!StringsAreEqual(GetCurrentWeapon(), "Pistol")) {
			iEnemy = GetClosestPlayerEnemy();
			if (iEnemy != -1) {
				SetEnemy(iEnemy);
				changestate(stateEngageEnemy);
			}
		}

		// Continue to roam around until we spot something.
		Roam(MOVEMENT_SPEED);

		if (iReSearchTimer > 0) {
			iReSearchTimer--;
		} else {
			// If we haven't found anything in a good while, allow searching for
			// everything again. Maybe something's opened up!
			memset(g_iAllowSearch, 1, 32768);
			iReSearchTimer = 2 * 35;
		}

		// If we still have a chat delay, simply tick it down, and don't talk!
		if (g_iChatTimer > 0) {
			g_iChatTimer--;
		} else {
			// How often we talk is determined by our chat frequency.
			iChatFrequency = GetChatFrequency();
			if (iChatFrequency > 0) {
				iChatFrequency = (100 - iChatFrequency) * 7;
				if (iChatFrequency < 35) {
					iChatFrequency = 35;
				}

				// If it's time to chat, do it!
				if (Random(0, iChatFrequency) == 0) {
					if (ChatSectionExistsInChatLump("RoamingStrings")) {
						// Spawn a chat bubble over our head, and pause slightly.
						BeginChatting();
						delay(Random(15, 45));

						// Say a really rare string!
						if (Random(0, 100) == 0) {
							if (ChatSectionExistsInChatLump("RareRoamingStrings")) {
								SayFromChatLump("RareRoamingStrings");
							} else {
								SayFromChatLump("RoamingStrings");
							}
						// If we're not in the lead, potentially say something from the "LosingRoaming" category.
						} else if (GetSpread() < 0) {
                            if (Random(0, 3) == 0) {
                                if (ChatSectionExistsInChatLump("LosingRoamingStrings")) {
                                    SayFromChatLump("LosingRoamingStrings");
                                } else {
                                    SayFromChatLump("RoamingStrings");
                                }
                            } else {
                                SayFromChatLump("RoamingStrings");
                            }
						// Otherwise, say something from the "RoamingStrings" category.
                        } else {
                            SayFromChatLump("RoamingStrings");
                        }
					}

					// Don't say anything else for at least 5 seconds.
					g_iChatTimer = 35 * 5;
				}
			}
		}

		// If we're demoralized or enraged, tick down that count.
		if (g_iDemoralizedTimer > 0) {
			g_iDemoralizedTimer--;
			if (g_iDemoralizedTimer == 0) {
				// We're no longer demoralized.
				SetSkillDecrease(false);

				// Restore our morale to 100%.
				g_iMorale = 100;
				g_iMoraleTimer = 35 * 3;
			}
		}
		else if (g_iEnragedTimer > 0) {
            g_iEnragedTimer--;
            if (g_iEnragedTimer == 0) {
                // We're no longer enraged.
                SetSkillIncrease(false);

                // Restore our morale to 100%.
                g_iMorale = 100;
                g_iMoraleTimer = 35 * 3;
            }
        } else {
			// Count down the morale timer. If it's expired, increase our morale a bit.
            if (g_iMoraleTimer > 0) {
                g_iMoraleTimer--;
            } else {
                g_iMorale++;
                if (g_iMorale > 100) {
                    g_iMorale = 100;
                }

				// Reset the morale timer.
                g_iMoraleTimer = 35 * 3;
            }
		}
	}

	onexit {
		// If were were chatting in this state, get rid of the chat bubble above our head.
		StopChatting();
	}
}
//*************************************************************************************************************
state stateSortThroughWeapons {
	int iCurrentItem;
	int iBestItem;
	int iCurrentCost;
	int iBestCost;
	bool iSightCheck;
	int iCurrentItemIsBetter;

	event KilledByEnemy {
		changestate(stateKilled);
	}

	event KilledByPlayer {
		changestate(stateKilled);
	}

	event KilledBySelf {
		changestate(stateKilled);
	}

	event KilledByEnvironment {
		changestate(stateKilled);
	}

	onenter {
		iCurrentItem = 0;
		iBestItem = -1;
		if (StringsAreEqual(GetCurrentWeapon(), "Pistol")) {
			iSightCheck = true;
		} else {
//			iSightCheck = false;
			// Pathing to items that aren't visible is currently a problem.
			iSightCheck = true;
		}
	}

	mainloop {
		// Find the next item in the item list, starting with iCurrentItem.
		iCurrentItem = LookForWeapons(iCurrentItem, iSightCheck);

		// If iCurrentItem is -1, then we've searched through all possible items.
		if (iCurrentItem == -1) {
			// Set the goal to best item that we found while scanning.
			if (iBestItem != -1) {
				SetGoal(iBestItem);
				changestate(statePathToGoal);
			}
			// Otherwise, nothing else we can do here.
			else {
				changestate(stateStandardRoam);
			}
		}

		// Ignore weapons that we already have.
		if (IsWeaponOwned(iCurrentItem)) {
			iCurrentItem++;
			return;
		}

        // Try to find the pathing cost of getting to this item.
        iCurrentCost = GetPathingCostToItem(iCurrentItem);

        // If iCurrentCost is < 0, then either a path to the item couldn't be created, or
        // it was too costly to try to get to that item.
        if (iCurrentCost < 0) {
            iCurrentItem++;
			return;
		}

        // If we haven't chosen an item as the best item thus far, set this item as the
        // best item.
        if (iBestItem == -1) {
            iBestItem = iCurrentItem;
            iBestCost = iCurrentCost;
            iCurrentItem++;
			return;
		}

        iCurrentItemIsBetter = 0;
/*
		// If this item is closer, it's better.
		if ((GetDistanceToItem(iCurrentItem)) < (GetDistanceToItem(iBestItem)))
			iCurrentItemIsBetter++;
		else
			iCurrentItemIsBetter--;

		// If this weapon ranks higher, it's better.
		if ((GetWeaponRank(iCurrentItem)) > (GetWeaponRank(iBestItem)))
			iCurrentItemIsBetter++;
		else
			iCurrentItemIsBetter--;
*/
        // Factor in whether or not it's cheaper to get to the current item.
        if (iCurrentCost < iBestCost) {
            iCurrentItemIsBetter++;
        } else {
            iCurrentItemIsBetter--;
        }

        // If we've determined that the current item is better, set it as the best item.
        if (iCurrentItemIsBetter > 0) {
            iBestItem = iCurrentItem;
            iBestCost = iCurrentCost;
        }

		iCurrentItem++;
/*
		// Continue to loop through the list of powerups until we find something
		while (LookForWeapons(iCurrentItem, iSightCheck) != -1) {
			int iCurrentItemIsBetter;

			// Look around for a powerup, starting with the last found one.
			iCurrentItem = LookForWeapons(iCurrentItem, iSightCheck);

			// Ignore weapons that we already have.
			if (IsWeaponOwned(iCurrentItem)) {
        iCurrentItem++;
				return;
			}

			// Try to find the pathing cost of getting to this item.
			iCurrentCost = GetPathingCostToItem(iCurrentItem);

			// If iCurrentCost is < 0, then either a path to the item couldn't be created, or
			// it was too costly to try to get to that item.
			if (iCurrentCost < 0) {
				iCurrentItem++;
				return;
			}

			// If we haven't chosen an item as the best item thus far, set this item as the
			// best item.
			if (iBestItem == -1) {
				iBestItem = iCurrentItem;
				iBestCost = iCurrentCost;
				iCurrentItem++;
				return;
			}

			iCurrentItemIsBetter = 0;
/*
			// If this weapon is closer, it's better.
			if ((GetDistanceToItem(iCurrentItem)) < (GetDistanceToItem(iBestItem)))
				iCurrentItemIsBetter++;
			else
				iCurrentItemIsBetter--;

			// If this weapon ranks higher, it's better.
			if ((GetWeaponRank(iCurrentItem)) > (GetWeaponRank(iBestItem)))
				iCurrentItemIsBetter++;
			else
				iCurrentItemIsBetter--;
*

			// Factor in whether or not it's cheaper to get to the current item.
			if (iCurrentCost < iBestCost)
				iCurrentItemIsBetter++;
			else
				iCurrentItemIsBetter--;

			// If we've determined that the current item is better, set it as the best item.
			if (iCurrentItemIsBetter) {
				iBestItem = iCurrentItem;
				iBestCost = iCost;
	}

			iCurrentItem++;
		}

		// Set the goal to best item that we found while scanning.
		if (iBestItem != -1) {
			SetGoal(iBestItem);
			changestate(statePathToGoal);
		}
		// Otherwise, nothing else we can do here.
		else {
			changestate(stateStandardRoam);
		}
*/
    }
}

//*************************************************************************************************************
state stateSortThroughPowerups {
	int iCurrentItem;
	int iBestItem;
	int iCurrentCost;
	int iBestCost;
	int iCurrentItemIsBetter;

	event KilledByEnemy {
		changestate(stateKilled);
	}

	event KilledByPlayer {
		changestate(stateKilled);
	}

	event KilledBySelf {
		changestate(stateKilled);
	}

	event KilledByEnvironment {
		changestate(stateKilled);
	}

	onenter {
		iCurrentItem = 0;
		iBestItem = -1;
	}

	mainloop {
		// Find the next item in the item list, starting with iCurrentItem.
		iCurrentItem = LookForPowerups(iCurrentItem, true);

		// If iCurrentItem is -1, then we've searched through all possible items.
		if (iCurrentItem == -1) {
			// Set the goal to best item that we found while scanning.
			if (iBestItem != -1) {
				SetGoal(iBestItem);
				changestate(statePathToGoal);
			}
			// Otherwise, nothing else we can do here.
			else {
				changestate(stateStandardRoam);
			}
		}

		// Try to find the pathing cost of getting to this item.
		iCurrentCost = GetPathingCostToItem(iCurrentItem);

		// If iCurrentCost is < 0, then either a path to the item couldn't be created, or
		// it was too costly to try to get to that item.
		if (iCurrentCost < 0) {
			iCurrentItem++;
			return;
		}

		// If we haven't chosen an item as the best item thus far, set this item as the
		// best item.
        if (iBestItem == -1) {
            iBestItem = iCurrentItem;
            iBestCost = iCurrentCost;
            iCurrentItem++;
			return;
		}

        iCurrentItemIsBetter = 0;
/*
		// If this item is closer, it's better.
		if ((GetDistanceToItem(iCurrentItem)) < (GetDistanceToItem(iBestItem)))
			iCurrentItemIsBetter++;
		else
			iCurrentItemIsBetter--;
*/
        // Factor in whether or not it's cheaper to get to the current item.
        if (iCurrentCost < iBestCost) {
            iCurrentItemIsBetter++;
        } else {
            iCurrentItemIsBetter--;
        }

        // If we've determined that the current item is better, set it as the best item.
        if (iCurrentItemIsBetter > 0) {
            iBestItem = iCurrentItem;
            iBestCost = iCurrentCost;
        }

        iCurrentItem++;
	}
}

//*************************************************************************************************************
state stateSortThroughBaseHealth {
	int iCurrentItem;
	int iBestItem;
	int iCurrentCost;
	int iBestCost;
	int iCurrentItemIsBetter;

	event KilledByEnemy {
		changestate(stateKilled);
	}

	event KilledByPlayer {
		changestate(stateKilled);
	}

	event KilledBySelf {
		changestate(stateKilled);
	}

	event KilledByEnvironment {
		changestate(stateKilled);
	}

	onenter {
		iCurrentItem = 0;
		iBestItem = -1;
	}

	mainloop {
        // Find the next item in the item list, starting with iCurrentItem.
		iCurrentItem = LookForBaseHealth(iCurrentItem, true);

		// If iCurrentItem is -1, then we've searched through all possible items.
		if (iCurrentItem == -1) {
			// Set the goal to best item that we found while scanning.
			if (iBestItem != -1) {
				SetGoal(iBestItem);
				changestate(statePathToGoal);
			}
			// Otherwise, nothing else we can do here.
			else {
				changestate(stateStandardRoam);
			}
		}

		// Try to find the pathing cost of getting to this item.
		iCurrentCost = GetPathingCostToItem(iCurrentItem);

		// If iCurrentCost is < 0, then either a path to the item couldn't be created, or
		// it was too costly to try to get to that item.
		if (iCurrentCost < 0) {
			iCurrentItem++;
			return;
		}

        // If we haven't chosen an item as the best item thus far, set this item as the
        // best item.
        if (iBestItem == -1) {
            iBestItem = iCurrentItem;
            iBestCost = iCurrentCost;
            iCurrentItem++;
			return;
		}

        iCurrentItemIsBetter = 0;
/*
		// If this item is closer, it's better.
		if ((GetDistanceToItem(iCurrentItem)) < (GetDistanceToItem(iBestItem)))
			iCurrentItemIsBetter++;
		else
			iCurrentItemIsBetter--;
*/
		// Factor in whether or not it's cheaper to get to the current item.
		if (iCurrentCost < iBestCost) {
            iCurrentItemIsBetter++;
        } else {
            iCurrentItemIsBetter--;
        }

        // If we've determined that the current item is better, set it as the best item.
        if (iCurrentItemIsBetter > 0) {
            iBestItem = iCurrentItem;
            iBestCost = iCurrentCost;
        }

        iCurrentItem++;
	}
}

//*************************************************************************************************************
state stateSortThroughBaseArmor {
	int iCurrentItem;
	int iBestItem;
	int iCurrentCost;
	int iBestCost;
	int iCurrentItemIsBetter;

	event KilledByEnemy {
		changestate(stateKilled);
	}

	event KilledByPlayer {
		changestate(stateKilled);
	}

	event KilledBySelf {
		changestate(stateKilled);
	}

	event KilledByEnvironment {
		changestate(stateKilled);
	}

	onenter {
		iCurrentItem = 0;
		iBestItem = -1;
	}

	mainloop {
		// Find the next item in the item list, starting with iCurrentItem.
		iCurrentItem = LookForBaseArmor(iCurrentItem, true);

        // If iCurrentItem is -1, then we've searched through all possible items.
		if (iCurrentItem == -1) {
            // Set the goal to best item that we found while scanning.
			if (iBestItem != -1) {
				SetGoal(iBestItem);
				changestate(statePathToGoal);
			}
            // Otherwise, nothing else we can do here.
			else {
				changestate(stateStandardRoam);
			}
		}

        // Try to find the pathing cost of getting to this item.
		iCurrentCost = GetPathingCostToItem(iCurrentItem);

        // If iCurrentCost is < 0, then either a path to the item couldn't be created, or
        // it was too costly to try to get to that item.
		if (iCurrentCost < 0) {
			iCurrentItem++;
			return;
		}

        // If we haven't chosen an item as the best item thus far, set this item as the
        // best item.
        if (iBestItem == -1) {
            iBestItem = iCurrentItem;
            iBestCost = iCurrentCost;
            iCurrentItem++;
			return;
		}

        iCurrentItemIsBetter = 0;
/*
		// If this item is closer, it's better.
		if ((GetDistanceToItem(iCurrentItem)) < (GetDistanceToItem(iBestItem)))
			iCurrentItemIsBetter++;
		else
			iCurrentItemIsBetter--;
*/
        // Factor in whether or not it's cheaper to get to the current item.
        if (iCurrentCost < iBestCost) {
            iCurrentItemIsBetter++;
        } else {
            iCurrentItemIsBetter--;
        }

        // If we've determined that the current item is better, set it as the best item.
        if (iCurrentItemIsBetter > 0) {
            iBestItem = iCurrentItem;
            iBestCost = iCurrentCost;
        }

        iCurrentItem++;
	}
}

//*************************************************************************************************************
state stateSortThroughSuperHealth {
	int iCurrentItem;
	int iBestItem;
	int iCurrentCost;
	int iBestCost;
	int iCurrentItemIsBetter;

	event KilledByEnemy {
		changestate(stateKilled);
	}

	event KilledByPlayer {
		changestate(stateKilled);
	}

	event KilledBySelf {
		changestate(stateKilled);
	}

	event KilledByEnvironment {
		changestate(stateKilled);
	}

	onenter {
		iCurrentItem = 0;
		iBestItem = -1;
	}

	mainloop {
        // Find the next item in the item list, starting with iCurrentItem.
		iCurrentItem = LookForSuperHealth(iCurrentItem, true);

        // If iCurrentItem is -1, then we've searched through all possible items.
		if (iCurrentItem == -1) {
            // Set the goal to best item that we found while scanning.
			if (iBestItem != -1) {
				SetGoal(iBestItem);
				changestate(statePathToGoal);
			}
            // Otherwise, nothing else we can do here.
			else {
				changestate(stateStandardRoam);
			}
		}

        // Try to find the pathing cost of getting to this item.
		iCurrentCost = GetPathingCostToItem(iCurrentItem);

        // If iCurrentCost is < 0, then either a path to the item couldn't be created, or
        // it was too costly to try to get to that item.
		if (iCurrentCost < 0) {
			iCurrentItem++;
			return;
		}

		// If we haven't chosen an item as the best item thus far, set this item as the
		// best item.
        if (iBestItem == -1) {
            iBestItem = iCurrentItem;
            iBestCost = iCurrentCost;
            iCurrentItem++;
			return;
		}

        iCurrentItemIsBetter = 0;
/*
		// If this item is closer, it's better.
		if ((GetDistanceToItem(iCurrentItem)) < (GetDistanceToItem(iBestItem)))
			iCurrentItemIsBetter++;
		else
			iCurrentItemIsBetter--;
*/
        // Factor in whether or not it's cheaper to get to the current item.
        if (iCurrentCost < iBestCost) {
            iCurrentItemIsBetter++;
        } else {
            iCurrentItemIsBetter--;
        }

        // If we've determined that the current item is better, set it as the best item.
        if (iCurrentItemIsBetter > 0) {
            iBestItem = iCurrentItem;
            iBestCost = iCurrentCost;
        }

        iCurrentItem++;
	}
}

//*************************************************************************************************************
state stateSortThroughSuperArmor {
	int iCurrentItem;
	int iBestItem;
	int iCurrentCost;
	int iBestCost;
	int iCurrentItemIsBetter;

	event KilledByEnemy {
		changestate(stateKilled);
	}

	event KilledByPlayer {
		changestate(stateKilled);
	}

	event KilledBySelf {
		changestate(stateKilled);
	}

	event KilledByEnvironment {
		changestate(stateKilled);
	}

	onenter {
		iCurrentItem = 0;
		iBestItem = -1;
	}

	mainloop {
        // Find the next item in the item list, starting with iCurrentItem.
		iCurrentItem = LookForSuperArmor(iCurrentItem, true);

        // If iCurrentItem is -1, then we've searched through all possible items.
		if (iCurrentItem == -1) {
            // Set the goal to best item that we found while scanning.
			if (iBestItem != -1) {
				SetGoal(iBestItem);
				changestate(statePathToGoal);
			}
            // Otherwise, nothing else we can do here.
			else {
				changestate(stateStandardRoam);
			}
		}

        // Try to find the pathing cost of getting to this item.
		iCurrentCost = GetPathingCostToItem(iCurrentItem);

		// If iCurrentCost is < 0, then either a path to the item couldn't be created, or
		// it was too costly to try to get to that item.
		if (iCurrentCost < 0) {
			iCurrentItem++;
			return;
		}

        // If we haven't chosen an item as the best item thus far, set this item as the
        // best item.
        if (iBestItem == -1) {
            iBestItem = iCurrentItem;
            iBestCost = iCurrentCost;
            iCurrentItem++;
			return;
		}

        iCurrentItemIsBetter = 0;
/*
		// If this item is closer, it's better.
		if ((GetDistanceToItem(iCurrentItem)) < (GetDistanceToItem(iBestItem)))
			iCurrentItemIsBetter++;
		else
			iCurrentItemIsBetter--;
*/
        // Factor in whether or not it's cheaper to get to the current item.
        if (iCurrentCost < iBestCost) {
            iCurrentItemIsBetter++;
        } else {
            iCurrentItemIsBetter--;
        }

        // If we've determined that the current item is better, set it as the best item.
        if (iCurrentItemIsBetter > 0) {
            iBestItem = iCurrentItem;
            iBestCost = iCurrentCost;
        }

        iCurrentItem++;
	}
}
//*************************************************************************************************************
state statePathToGoal {
	int iEnemy;
	int iChatFrequency;
	int iResult;

	event KilledByEnemy {
		changestate(stateKilled);
	}

	event KilledByPlayer {
		changestate(stateKilled);
	}

	event KilledBySelf {
		changestate(stateKilled);
	}

	event KilledByEnvironment {
		changestate(stateKilled);
	}

	event ReachedGoal {
		changestate(stateStandardRoam);
	}

	event GoalRemoved {
		changestate(stateStandardRoam);
	}

	event DamagedByPlayer {
		if (!StringsAreEqual(GetCurrentWeapon(), "Pistol")) {
			// Make our enemy the last player that shot us.
			SetEnemy(GetPlayerDamagedBy());
			changestate(stateEngageEnemy);
		}
	}

	mainloop {
		// Run towards our goal object.
		iResult = PathToGoal(MOVEMENT_SPEED);
		switch (iResult) {
		case PATH_UNREACHABLE:

			changestate(stateStandardRoam);
			break;
		}

		// Also, look for enemies along the way.
		if (!StringsAreEqual(GetCurrentWeapon(), "Pistol")) {
			iEnemy = LookForPlayerEnemies(0);
			if (iEnemy != -1) {
				SetEnemy(iEnemy);
				changestate(stateEngageEnemy);
			}
		}

		if (g_iChatTimer > 0) {
			g_iChatTimer--;
		} else {
			// How often we talk is determined by our chat frequency.
			iChatFrequency = GetChatFrequency();
			if (iChatFrequency > 0) {
				iChatFrequency = (100 - iChatFrequency) * 7;
				if (iChatFrequency < 35) {
					iChatFrequency = 35;
				}

				// If it's time to chat, do it!
				if (Random(0, iChatFrequency) == 0) {
					if (ChatSectionExistsInChatLump("RoamingStrings")) {
						// Spawn a chat bubble over our head, and pause slightly.
						BeginChatting();
						delay(Random(15, 45));

						// Say a really rare string!
						if (Random(0, 100) == 0) {
							if (ChatSectionExistsInChatLump("RareRoamingStrings")) {
								SayFromChatLump("RareRoamingStrings");
							} else {
								SayFromChatLump("RoamingStrings");
							}
						// If we're not in the lead, say something from the "LosingRoaming" category.
						} else if (GetSpread() < 0) {
                            if (Random(0, 3) == 0) {
                                if (ChatSectionExistsInChatLump("LosingRoamingStrings")) {
                                    SayFromChatLump("LosingRoamingStrings");
                                } else {
                                    SayFromChatLump("RoamingStrings");
                                }
                            } else {
                                SayFromChatLump("RoamingStrings");
                            }
                        // Otherwise, say something from the "RoamingStrings" category.
                        } else {
                            SayFromChatLump("RoamingStrings");
						}
					}

					// Don't say anything else for at least 5 seconds.
					g_iChatTimer = 35 * 5;
				}
			}
		}

		// If we're demoralized or enraged, tick down that count.
		if (g_iDemoralizedTimer > 0) {
			g_iDemoralizedTimer--;
			if (g_iDemoralizedTimer == 0) {
				// We're no longer demoralized.
				SetSkillDecrease(false);

				// Restore our morale to 100%.
				g_iMorale = 100;
				g_iMoraleTimer = 35 * 3;
			}
		} else if (g_iEnragedTimer > 0) {
            g_iEnragedTimer--;
            if (g_iEnragedTimer == 0) {
                // We're no longer enraged.
                SetSkillIncrease(false);

                // Restore our morale to 100%.
                g_iMorale = 100;
                g_iMoraleTimer = 35 * 3;
            }
        } else {
            // Count down the morale timer. If it's expired, increase our morale a bit.
            if (g_iMoraleTimer > 0) {
                g_iMoraleTimer--;
            } else {
                g_iMorale++;
                if (g_iMorale > 100) {
                    g_iMorale = 100;
                }

                // Reset the morale timer.
                g_iMoraleTimer = 35 * 3;
            }
        }
	}

	onexit {
		// If were were chatting in this state, get rid of the chat bubble above our head.
		StopChatting();
	}
}

//*************************************************************************************************************
state stateEngageEnemy {
	int iDistance;
	bool iLeft;
	int iStrafeTimer;
	int iChaingunReFirePause;
	int iEnemyShotgunReFireTicks;
	int iDodgingHitscanTicks;
	int iCurrentDirection;
	int i;

	event KilledByEnemy {
		changestate(stateKilled);
	}

	event KilledByPlayer {
		changestate(stateKilled);
	}

	event KilledBySelf {
		changestate(stateKilled);
	}

	event KilledByEnvironment {
		changestate(stateKilled);
	}

	event EnemyKilled {
		changestate(stateKilledEnemy);
	}

	event EnemyFiredShotgun {
		iEnemyShotgunReFireTicks = 37 - 17;
	}

	event EnemyFiredSSG {
		iEnemyShotgunReFireTicks = 57 - 17;
	}

	onenter {
		// While in this state, constantly aim and fire at our enemy.
		BeginFiringWeapon();
		BeginAimingAtEnemy();

		iChaingunReFirePause = 0;

		// Randomly decide whether or not to begin strafing right or left.
		iLeft = Random(0, 1) != 0;

		// Initialize the strafe timer.
		iStrafeTimer = Random(1, 62);
		if (iLeft) {
			MoveLeft(MOVEMENT_SPEED);
		} else {
			MoveRight(MOVEMENT_SPEED);
		}

		iEnemyShotgunReFireTicks = 0;
		iDodgingHitscanTicks = 0;
	}

	mainloop {
		// If we can't see our enemy anymore, and we don't see anyone else, chase him down!
		if (!IsEnemyVisible()) {
            int iEnemy;

			iEnemy = GetClosestPlayerEnemy();
			if (iEnemy == -1) {
				changestate(stateChaseEnemy);
			} else {
				SetEnemy(iEnemy);
				changestate(stateEngageEnemy);
			}
		}
		
		// If our enemy is dead, go back to roaming around.
		if (!IsEnemyAlive()) {
			ClearEnemy();
			changestate(stateStandardRoam);
		}

		// If we sense that the enemy is about to fire at us again with the SSG, change our direction
		// to throw him off.
		if (iEnemyShotgunReFireTicks != 0) {
			iEnemyShotgunReFireTicks--;
			if (iEnemyShotgunReFireTicks == 0) {
				iDodgingHitscanTicks = Random(12, 35);
				iCurrentDirection = Random(NORTH, NUM_DIRECTIONS);

				StopMovement();

				switch (iCurrentDirection) {
                case NORTH:

                    MoveForward(MOVEMENT_SPEED);
                    break;
                case NORTHEAST:

                    MoveForward(MOVEMENT_SPEED);
                    MoveRight(MOVEMENT_SPEED);
                    break;
                case EAST:

                    MoveRight(MOVEMENT_SPEED);
                    break;
                case SOUTHEAST:

                    MoveBackwards(MOVEMENT_SPEED);
                    MoveRight(MOVEMENT_SPEED);
                    break;
                case SOUTH:

                    MoveBackwards(MOVEMENT_SPEED);
                    break;
                case SOUTHWEST:

                    MoveBackwards(MOVEMENT_SPEED);
                    MoveLeft(MOVEMENT_SPEED);
                    break;
                case WEST:

                    MoveLeft(MOVEMENT_SPEED);
                    break;
				case NORTHWEST:

					MoveForward(MOVEMENT_SPEED);
					MoveLeft(MOVEMENT_SPEED);
					break;
				}
			}
		}

		if (iDodgingHitscanTicks == 0) {
			// Get the distance to our enemy. See if we need to position ourselves better to him, given our
			// current weapon.
			iDistance = GetDistanceToEnemy();

			if (StringsAreEqual(GetCurrentWeapon(), "Chaingun")) {
				if (iDistance < 256) {
					MoveBackwards(MOVEMENT_SPEED);
				} else {
					StopForwardMovement();
				}
			} else {
				if (iDistance > 384) {
					MoveForward(MOVEMENT_SPEED);
				} else if (iDistance < 128) {
                    MoveBackwards(MOVEMENT_SPEED);
                } else {
                    i = Random(0, 1);
                    if (i == 0) {
                        MoveForward(MOVEMENT_SPEED);
                    } else {
                        MoveBackwards(MOVEMENT_SPEED);
                    }
                }
			}

			// Randomly switch up strafing left and right.
			iStrafeTimer--;
			if (iStrafeTimer == 0) {
				iLeft = (!iLeft);
				if (iLeft) {
					MoveLeft(MOVEMENT_SPEED);
				} else {
					MoveRight(MOVEMENT_SPEED);
				}
				iStrafeTimer = Random(1, 62);
			}
		} else {
			iDodgingHitscanTicks--;
		}

		// If we're using the chaingun, use a little trick where we can let go of the fire button, until
		// the shot is done firing, then hit it again afterwards. This gets rid of the inaccuracy of holding
		// the fire button down continously.
		if (StringsAreEqual(GetCurrentWeapon(), "Chaingun")) {
			StopFiringWeapon();

			if (iChaingunReFirePause != 0) {
				iChaingunReFirePause--;
			}

			// Okay, done pausing! Refire!
			if (iChaingunReFirePause == 0) {
				FireWeapon();
				iChaingunReFirePause = 9;
			}
		} else {
			BeginFiringWeapon();
		}

		// If we're demoralized or enraged, tick down that count.
		if (g_iDemoralizedTimer > 0) {
			g_iDemoralizedTimer--;
			if (g_iDemoralizedTimer == 0) {
				// We're no longer demoralized.
				SetSkillDecrease(false);

				// Restore our morale to 100%.
				g_iMorale = 100;
				g_iMoraleTimer = 35 * 3;
			}
		} else if (g_iEnragedTimer > 0) {
            g_iEnragedTimer--;
            if (g_iEnragedTimer == 0) {
                // We're no longer enraged.
                SetSkillIncrease(false);

                // Restore our morale to 100%.
                g_iMorale = 100;
                g_iMoraleTimer = 35 * 3;
            }
        } else {
            // Count down the morale timer. If it's expired, increase our morale a bit.
            if (g_iMoraleTimer > 0) {
                g_iMoraleTimer--;
            } else {
                g_iMorale++;
                if (g_iMorale > 100) {
                    g_iMorale = 100;
                }

                // Reset the morale timer.
                g_iMoraleTimer = 35 * 3;
            }
        }
	}

	onexit {
		StopMovement();
		StopFiringWeapon();
		StopAimingAtEnemy();
	}
}

//*************************************************************************************************************
state stateChaseEnemy {
	int iEnemy;
	int iResult;

	event KilledByEnemy {
		changestate(stateKilled);
	}

	event KilledByPlayer {
		changestate(stateKilled);
	}

	event KilledBySelf {
		changestate(stateKilled);
	}

	event KilledByEnvironment {
		changestate(stateKilled);
	}

	event DamagedByPlayer {
        // Make our enemy the last player that shot us.
		if (!StringsAreEqual(GetCurrentWeapon(), "Pistol")) {
			SetEnemy(GetPlayerDamagedBy());
			changestate(stateEngageEnemy);
		}
	}

	mainloop {
		iEnemy = GetClosestPlayerEnemy();
		if (iEnemy != -1) {
			SetEnemy(iEnemy);
			changestate(stateEngageEnemy);
		}

		// Path to the last known enemy position (heh).
		iResult = PathToLastKnownEnemyPosition(MOVEMENT_SPEED);
		switch (iResult) {
		case PATH_UNREACHABLE:

			ClearEnemy();
			changestate(stateStandardRoam);
			break;
        case PATH_REACHEDGOAL:

            // If we got to where we last saw our enemy and don't see him, give up.
            ClearEnemy();
            changestate(stateStandardRoam);
            break;
		}

		// If we're demoralized or enraged, tick down that count.
		if (g_iDemoralizedTimer > 0) {
			g_iDemoralizedTimer--;
			if (g_iDemoralizedTimer == 0) {
				// We're no longer demoralized.
				SetSkillDecrease(false);

				// Restore our morale to 100%.
				g_iMorale = 100;
				g_iMoraleTimer = 35 * 3;
			}
		} else if (g_iEnragedTimer > 0) {
            g_iEnragedTimer--;
            if (g_iEnragedTimer == 0) {
                // We're no longer enraged.
                SetSkillIncrease(false);

                // Restore our morale to 100%.
                g_iMorale = 100;
                g_iMoraleTimer = 35 * 3;
            }
        } else {
            // Count down the morale timer. If it's expired, increase our morale a bit.
            if (g_iMoraleTimer > 0) {
                g_iMoraleTimer--;
            } else {
                g_iMorale++;
                if (g_iMorale > 100) {
                    g_iMorale = 100;
                }

                // Reset the morale timer.
                g_iMoraleTimer = 35 * 3;
            }
        }
	}
}

//*************************************************************************************************************
state stateKilled {
	int iChatFrequency;
	int iMedal;

	event Respawned {
		changestate(stateRespawn);
	}

	event ReceivedMedal {
		iMedal = GetReceivedMedal();
		switch (iMedal) {
		case MEDAL_YOUFAILIT:
        case MEDAL_YOURSKILLISNOTENOUGH:

			// Lower our morale quite a bit.
			g_iMorale -= 25;
			break;
		}
	}

	onenter {
		delay(Random(5, 15));

		// Lower our morale a bit.
		g_iMorale -= 15;
		if (!IsSkillDecreased() && (g_iMorale < 0)) {
			// If we lose all our morale while enraged, we become demoralized.
			if (IsSkillIncreased()) {
				// We're now demoralized.
				SetSkillDecrease(true);
				SetSkillIncrease(false);

				// Let the player know we're demoralized.
				if (ChatSectionExistsInChatLump("DemoralizedStrings")) {
					// Spawn a chat bubble above our head, and pause slightly.
					BeginChatting();
					delay(Random(15, 45));

					// Say something witty from our "DemoralizedStrings" section.
					SayFromChatLump("DemoralizedStrings");
				}

				// Don't say anything else for at least 5 seconds.
				g_iChatTimer = 35 * 5;

				// Stay demoralized for a good minute or so.
				g_iDemoralizedTimer = 35 * 60;
				g_iEnragedTimer = 0;
			}
			// Otherwise, we become enraged.
			else {
				// We're now enraged.
				SetSkillIncrease(true);
				SetSkillDecrease(false);

				// Let the player know we're pissed.
				if (ChatSectionExistsInChatLump("EnragedStrings")) {
					// Spawn a chat bubble above our head, and pause slightly.
					BeginChatting();
					delay(Random(15, 45));

					// Say something witty from our "EnragedStrings" section.
					SayFromChatLump("EnragedStrings");
				}

				// Don't say anything else for at least 5 seconds.
				g_iChatTimer = 35 * 5;

				// Stay enraged for a good minute or so.
				g_iEnragedTimer = 35 * 60;
				g_iDemoralizedTimer = 0;

				// Give the bot a good 75% morale. If this falls to zero while enraged, the bot
				// will become frustrated.
				g_iMorale = 75;
			}
		} else {
			// How often we talk is determined by our chat frequency.
			iChatFrequency = GetChatFrequency();
			if ((iChatFrequency > 0) && (g_iChatTimer == 0)) {
				iChatFrequency = (100 - iChatFrequency) / 5;
				if (iChatFrequency < 2) {
					iChatFrequency = 2;
				}

				// If it's time to chat, do it!
				if (Random(0, iChatFrequency) == 0) {
					if (ChatSectionExistsInChatLump("KilledStrings")) {
                        // Spawn a chat bubble above our head, and pause slightly.
						BeginChatting();
						delay(Random(15, 45));

						// Say something witty from our "KilledStrings" section.
						SayFromChatLump("KilledStrings");
					}

					// Don't say anything else for at least 5 seconds.
					g_iChatTimer = 35 * 5;
				}
			}
		}
	}

	mainloop {
		// Hold space so that the bot can respawn.
		Respawn();
	}

	onexit {
		// If were were chatting in this state, get rid of the chat bubble above our head.
		StopChatting();
	}
}

//*************************************************************************************************************
state stateRespawn {

	event KilledByEnemy {
		changestate(stateKilled);
	}

	event KilledByPlayer {
		changestate(stateKilled);
	}

	event KilledBySelf {
		changestate(stateKilled);
	}

	event KilledByEnvironment {
		changestate(stateKilled);
	}

	onenter {
		// Weapons are the most important.
		if (LookForWeapons(0, false) != -1) {
			changestate(stateSortThroughWeapons);
		} else {
			changestate(stateStandardRoam);
		}
	}

	mainloop {
	}
}

//*************************************************************************************************************
state stateKilledEnemy {
	int iEnemy;
	int iChatFrequency;
	int iMedal;

	event KilledByEnemy {
		changestate(stateKilled);
	}

	event KilledByPlayer {
		changestate(stateKilled);
	}

	event KilledBySelf {
		changestate(stateKilled);
	}

	event KilledByEnvironment {
		changestate(stateKilled);
	}

	event ReceivedMedal {
		iMedal = GetReceivedMedal();
		switch (iMedal) {
		case MEDAL_EXCELLENT:
		case MEDAL_INCREDIBLE:
		case MEDAL_IMPRESSIVE:
		case MEDAL_MOSTIMPRESSIVE:
		case MEDAL_DOMINATION:
		case MEDAL_TOTALDOMINATION:
		case MEDAL_ACCURACY:
		case MEDAL_PRECISION:

			// Increase our morale a bit.
			g_iMorale += 15;
			break;
		}
	}

	onenter {
		// Increase our morale a bit.
		g_iMorale += 10;
		if (g_iMorale > 100) {
			g_iMorale = 100;
		}
		iEnemy = GetClosestPlayerEnemy();
		if (iEnemy != -1) {
			SetEnemy(iEnemy);
			changestate(stateEngageEnemy);
		}

		// How often we talk is determined by our chat frequency.
		iChatFrequency = GetChatFrequency();
		if ((iChatFrequency > 0) && (g_iChatTimer == 0)) {
			iChatFrequency = (100 - iChatFrequency) / 6;
			if (iChatFrequency < 2) {
				iChatFrequency = 2;
			}

			// If it's time to chat, do it!
			if (Random(0, iChatFrequency) == 0) {
				if (ChatSectionExistsInChatLump("FragStrings")) {
					// Spawn a chat bubble above our head, and pause slightly.
					BeginChatting();
					delay(Random(15, 45));

					// Say something from our "FragStrings" section.
					SayFromChatLump("FragStrings");
				}

				// Don't say anything else for at least 5 seconds.
				g_iChatTimer = 35 * 5;
			}
		}

		// Clear out the existing enemy. We no longer have an enemy target.
		ClearEnemy();

		// Go back to running around.
		changestate(stateStandardRoam);
	}

	mainloop {
	}

	onexit {
		// If were were chatting in this state, get rid of the chat bubble above our head.
		StopChatting();
	}
}

//*************************************************************************************************************
state stateIntermission {

	event NewMap {
		changestate(stateStandardRoam);
	}

	event KilledByEnemy {
		changestate(stateKilled);
	}

	event KilledByPlayer {
		changestate(stateKilled);
	}

	event KilledBySelf {
		changestate(stateKilled);
	}

	event KilledByEnvironment {
		changestate(stateKilled);
	}

	onenter {
		// Pause, then spew out a victory/loss string.
		delay(Random(35, 70));
		if (GetSpread() >= 0) {
			if (ChatSectionExistsInChatLump("WinStrings")) {
				SayFromChatLump("WinStrings");
			}
		} else {
			if (ChatSectionExistsInChatLump("LoseStrings")) {
				SayFromChatLump("LoseStrings");
			}
		}
	}

	mainloop {
	}
}

//*************************************************************************************************************
state stateSpectating {

	event JoinedGame {
		changestate(stateSpawn);
	}

	onenter {
		// Try to rejoin the game. If we don't join right away, we'll at least be put in line, in
		// which case we'll join later. Wait patiently until then.
		TryToJoinGame();
	}

	mainloop {
	}
}

//*************************************************************************************************************
state stateDuelWinSequence {
	onenter {
		// If we're up by at least one frag, we must have won!
		if (GetSpread() > 0) {
			if (ChatSectionExistsInChatLump("WinStrings")) {
				BeginChatting();
				delay(Random(15, 45));

				SayFromChatLump("WinStrings");
			}
		} else {
			if (ChatSectionExistsInChatLump("LoseStrings")) {
				BeginChatting();
				delay(Random(15, 45));

				SayFromChatLump("LoseStrings");
			}
		}
	}

	mainloop {
		// Just wait until the end of the sequence.
	}
}
